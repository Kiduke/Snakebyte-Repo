#pragma config(Hubs,  S1, HTMotor,  HTMotor,  none,     none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     HTAC,           sensorI2CCustom)
#pragma config(Sensor, S3,     HTIR,           sensorHiTechnicIRSeeker1200)
#pragma config(Motor,  mtr_S1_C1_1,     motorFL,       tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C1_2,     motorBL,       tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C2_1,     motorFR,       tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     motorBR,       tmotorTetrix, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "drivers/hitechnic-accelerometer.h";
#include "JoystickDriver.c"

// Acceleration
short xA = 0;
short yA = 0;
short zA = 0;

// Velocity
float xV = 0;

// Displacement
float xD = 0;

// Acceleration variable used for equations & accelerometer offset
float A  = 0;
float offset = 0;

// Defining Methods
void moveTo(float dis){
	xV = 0;

	// Move forward if dis > 0
	if(dis > 0){
		while(xD < dis){
			motor[motorFL] = 25;
			motor[motorBL] = 25;
			motor[motorFR] = 25;
			motor[motorBR] = 25;
		}
	motor[motorFL] = 0;
	motor[motorBL] = 0;
	motor[motorFR] = 0;
	motor[motorBR] = 0;

	// Move backward if dis < 0
	}if(dis < 0){
		while(xD > dis){
			motor[motorFL] = -25;
			motor[motorBL] = -25;
			motor[motorFR] = -25;
			motor[motorBR] = -25;
		}
	motor[motorFL] = 0;
	motor[motorBL] = 0;
	motor[motorFR] = 0;
	motor[motorBR] = 0;

	// Test if wait works
	wait10Msec(25);
	xV = 0;
	}
}

// Task that runs all autonomous code (Moving, irSeeker, etc)
task autonomous(){

	moveTo(2);

}

task main(){

	StartTask(autonomous);

	// Get first reading of accelerometer and calibrate the x axis
	HTACreadAllAxes(HTAC, xA, yA, zA);
	offset = xA * -1;

	wait10Msec(5);
	// Reads the accelerometer axes and returns 3 values
	while(true){

		// Numbers recieved are 1/200th of 1G
		HTACreadAllAxes(HTAC, xA, yA, zA);

		//if(xA < offset - 1 && xA > offset + 1){

			// Normalize acceleration by the offset in increments of 200ths of a G
			// Acceleration in m/s^2 = acceleration / 9.8
			A = (xA + offset) / (200 / 9.8);

			// Distance = Velocity * Time + Acceleration * Time^2 divided by 2
			xD += .5 * (A * .0025) + (xV * .05);

			// Solving for and recording velocity in the x direction
			// Acceleration * Time = V
			xV += (A * .05);
		//}

		wait10Msec(5);
	}
}
