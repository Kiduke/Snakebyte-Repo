#pragma config(Hubs,  S1, HTMotor,  HTMotor,  none,     none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S4,     HTMC,           sensorI2CHiTechnicCompass)
#pragma config(Motor,  mtr_S1_C1_1,     motorFL,       tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C1_2,     motorBL,       tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C2_1,     motorFR,       tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     motorBR,       tmotorTetrix, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//Global variables
short startPos;
short endPos;
short current;

// turn() method
void turn(float deg){
	startPos = 	SensorValue[HTMC];
	endPos = startPos + deg;

	// Turn right
	if(deg>0){
   	endPos = startPos + deg;

   	// Check if the robot is going to turn past 0 and prevent the value from going higher than it can handle
		if(endPos>359){
			endPos = endPos - 360;
		}

		// Set the current value
		current = SensorValue[HTMC];

		// If the robot will turn past zero, this will turn it to zero
		if (current>endPos){

			while(current > endPos){
				current = SensorValue[HTMC];
				motor[motorFL] = 25;
				motor[motorBL] = 25;
				motor[motorFR] = -25;
				motor[motorBR] = -25;
			}
			motor[motorFL] = 0;
			motor[motorBL] = 0;
			motor[motorFR] = 0;
			motor[motorBR] = 0;
		}

		// Once it hits zero, or if it won't pass zero, turn until it hits its destination
		if (current<endPos){

			while(current < endPos){
				current = SensorValue[HTMC];
				motor[motorFL] = 25;
				motor[motorBL] = 25;
				motor[motorFR] = -25;
				motor[motorBR] = -25;
			}
			motor[motorFL] = 0;
			motor[motorBL] = 0;
			motor[motorFR] = 0;
			motor[motorBR] = 0;
		}
	}

	// Turn left
	if(deg<0){
   	endPos = startPos + deg;

   	// Allow the robot to turn past zero without giving the end position a value higher than 359
		if(endPos<0){
			endPos = endPos + 360;
		}
		// Set the current sensor value
		current = SensorValue[HTMC];

		// Once again, check if the robot will hit zero during its turn, then turn it until it hits 359
		if(current<endPos){

			while(current < endPos){
				current = SensorValue[HTMC];
				motor[motorFL] = -25;
				motor[motorBL] = -25;
				motor[motorFR] = 25;
				motor[motorBR] = 25;
			}
			motor[motorFL] = 0;
			motor[motorBL] = 0;
			motor[motorFR] = 0;
			motor[motorBR] = 0;
		}

		// Once it hits 359, or if it won't, turn left until it hits its destination
		if (current>endPos){

			while(current > endPos){
				current = SensorValue[HTMC];
				motor[motorFL] = -25;
				motor[motorBL] = -25;
				motor[motorFR] = 25;
				motor[motorBR] = 25;
			}
			motor[motorFL] = 0;
			motor[motorBL] = 0;
			motor[motorFR] = 0;
			motor[motorBR] = 0;
		}
	}
}

task main(){

	wait10Msec(5);

	turn(-100);
}
